---
title: "dyngen: a multi-modal simulator for spearheading new single-cell omics analyses"
author:
- Robrecht Cannoodt*
- Wouter Saelens*
- Louise Deconinck
- Yvan Saeys
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  pdf_document:
    keep_tex: yes
    latex_engine: xelatex
    citation_package: biblatex
biblatexoptions: sorting=none
classoption:
- table
- 10pt
- a4paper
header-includes: |
  \usepackage{tcolorbox}
  \usepackage{colortbl}
  \usepackage{booktabs}
  \usepackage{tabularx}
  \usepackage{fontspec}
  \usepackage{pifont}
  \setmainfont [Path = fonts/,
    UprightFont = *-300,
    ItalicFont = *-300-Italic,
    BoldFont = *-700,
    BoldItalicFont = *-700-Italic
  ]{MuseoSans}
bibliography: library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse=TRUE, results="hold")
library(tidyverse)
```

# Abstract
**Purpose:** When developing new types of tools for single-cell analyses, there is often a lack of datasets on which to quantitatively assess the performance.  
**Results:** We developed dyngen, a multi-modality simulator of single cells. In dyngen, the biomolecular state of an _in silico_ cell changes over time according to a predefined gene regulatory network.  We used dyngen to benchmark three emerging ways of analysing single-cell data: RNA velocity, cell-specific network inference and trajectory alignment methods.  
**Conclusion:** dyngen lays the foundations for benchmarking a wide variety of computational single-cell tools and can be used to help kick-start the development of future types of analyses.


# Introduction {#sec:dyngen-introduction}
Continuous technological advancements to single-cells omics are having profound effects on how researchers can validate biological hypotheses. Early experimental technologies typically only allowed profiling a single modality (e.g. DNA sequence, RNA or protein expression). However, recent developments permit profiling multiple modalities simultaneously, and every modality added allows for new types of analyses that can be performed.

This confronts method developers with several challenges. The majority of the 250+ peer-reviewed computational tools for analysing single-cell omics data were published without a quantitative assessment of the accuracy of the tool. This is partially due to low availability of suitable benchmarking datasets; even if there are sufficient suitable input datasets available, these are often not accompanied by the necessary metadata to serve as ground-truth for a benchmark.

Here, synthetic data plays a crucial role in asserting minimum performance requirements for novel tools in anticipation of adequate real data. Generators of scRNA-seq data (e.g. splatter [@zappia_splattersimulationsinglecell_2017], powsimR [@vieth_powsimrpoweranalysis_2017], PROSSTT [@papadopoulos_prossttprobabilisticsimulation_2018] and SymSim [@zhang_simulatingmultiplefaceted_2019]) have already been widely used to explore the strengths and weaknesses of computational tools, both by method developers [@street_slingshotcelllineage_2018; @parra_reconstructingcomplexlineage_2018; @lummertzdarocha_reconstructioncomplexsinglecell_2018; @lin_scclassifyhierarchicalclassification_2019] and independent benchmarkers [@duo_systematicperformanceevaluation_2018; @saelens_comparisonsinglecelltrajectory_2019; @soneson_biasrobustnessscalability_2018].
However, a limitation of existing scRNA-seq profiles generators is that they would require significant methodological alterations to add additional modalities or experimental conditions.


<!--
\newcommand{\yes}{\ding{51}}
\newcommand{\no}{}
\newcommand{\grayline}{\arrayrulecolor{lightgray}\cline{3-7}}
\newcommand{\blackline}{\arrayrulecolor{black}\cline{3-7}}
\newcommand{\method}[1]{#1}

\begin{table}[htb!]
    \centering
    \begin{tabular}{p{.25cm}l|*{5}{>{\centering\arraybackslash}p{1.25cm}|}}
    \blackline
    & \method{} & \method{splatter} & \method{powsimR} & \method{PROSSTT} & \method{SymSim} & \method{dyngen} \\
    & & \cite{zappia_splattersimulationsinglecell_2017} & \cite{vieth_powsimrpoweranalysis_2017} & \cite{papadopoulos_prossttprobabilisticsimulation_2018} & \cite{zhang_simulatingmultiplefaceted_2019} & \\
    \blackline
    \multicolumn{7}{l}{\textbf{Available modality outputs}} \\
    \blackline
    - & mRNA expression & \yes & \yes & \yes & \yes & \yes \\ \grayline
    - & Pre-mRNA expression & \no & \no & \no & \no & \yes \\ \grayline
    - & Protein expression & \no & \no & \no & \no & \yes \\ \grayline
    - & Promotor activity & \no & \no & \no & \yes & \yes \\ \grayline
    - & Reaction activity & \no & \no & \no & \no & \yes \\
    \blackline
    \multicolumn{7}{l}{\textbf{Available ground-truth outputs}} \\
    \blackline
    - & True counts & \yes & \no & \no & \yes & \yes \\ \grayline
    - & Cluster labels & \yes & \yes & \no & \yes & ? \\ \grayline
    - & Trajectory & \yes & \no & \yes $ ^1$ & \yes & \yes \\ \grayline
    - & Batch labels & \yes & \no & \no & \no & \yes $ ^1$ \\ \grayline
    - & Differential expression & \no & \no & \no & \yes & \yes $^2$ \\ %\grayline
    - & Knocked down regulators & \no & \no & \no & \no & \yes \\ \grayline
- & Regulatory network & \no & \no & \no & \yes & \yes \\ \grayline
- & Cell-specific regulatory network & \no & \no & \no & \no & \yes \\
    \blackline
    \multicolumn{7}{l}{\textbf{Emulate experimental effects}} \\
    \blackline
    - & Single-cell RNA sequencing & \yes & \yes & \yes & \yes & \yes \\ \grayline
    - & Batch effects & \yes & \no & \no & \no & \yes $ ^1$ \\ \grayline
    - & Knockdown experiment & \no & \no & \no & \no & \yes \\ \grayline
    - & Time-series & ? & ? & ? & ? & \yes \\
    - & Snapshot & ? & ? & ? & ? & \yes \\
    \blackline
    \multicolumn{7}{l}{\textbf{Possible applications}} \\
    \blackline
    - & Clustering & \yes & \yes & \no & \yes & ? \\ \grayline
    - & Trajectory inference & \yes & \no & \yes & \yes & \yes \\ \grayline
    - & Network inference & \no & \no & \no & \yes & \yes \\ \grayline
    - & Cell-specific network inference & \no & \no & \no & \no & \yes \\ \grayline
    - & Differential expression & \yes & \no & \no & \no & \yes $^2$ \\ \grayline
    - & Batch effect correction & \yes & \no & \no & \no & \yes \\ \grayline
    - & RNA Velocity & \no & \no & \no & \no & \yes \\ \grayline
    - & Trajectory alignment & \no & \no & \no & \no & \yes \\
    \blackline
    \multicolumn{7}{l}{\textbf{Showcased dataset}} \\
    \blackline
    - & Number of cells &  &  &  &  & \\
    - & Number of genes &  &  &  &  & \\
    - & Execution time & & & & & \\
    \blackline
    \end{tabular}
    \caption{
    \textbf{Comparison of single-cell simulators.}
    $ ^1$ Showcased by vignette. $^2$ Showcased by Van den Berge et al.  \cite{vandenberge_trajectorybaseddifferentialexpression_2019}.
    }
    \label{tab:compare}
\end{table}
-->

An ideal experiment would be able to observe all aspects of a cell, including a full history of its molecular states, spatial positions and environmental interactions [@stuart_integrativesinglecellanalysis_2019].
While this falls outside the reach of current experimental technologies, generating synthetic data in anticipation of new experimental technologies would allow developing the next wave of computational tools.

We developed a multi-modality simulator of single cells called dyngen (Figure\ \ref{fig:showcase}A). dyngen uses an optimized version of Gillespie's stochastic simulation algorithm [@gillespie_exactstochasticsimulation_1977]  to simulate gene regulation, splicing, and translation at a single-molecule level. Its methodology allows tracking of many layers of information throughout the simulation, including the abundance of any molecule in the cell, the progression of the cell along a dynamic process, and the activation strength of individual regulatory interactions. dyngen can simulate a large variety of dynamic processes (e.g. cyclic, branching, disconnected) as well as a broad range of experimental conditions (e.g. batch effects and time-series, perturbation and knockdown experiments). The fine-grained controls over simulation parameters allow dyngen to be applicable to a broad range of use-cases. We demonstrate this by performing the first quantitative evaluations of three types of novel computational approaches: RNA velocity, cell-specific network inference, and trajectory alignment methods.

\begin{figure}[htb!]
    \centering
    \includegraphics[width=\linewidth]{result_files/fig1_showcase_functionality/overview_1.pdf}
    \caption{
        \textbf{Showcase of dyngen functionality.}
        \textbf{A:} The typical process of generating a dataset with dyngen.
        \textbf{B:} Evaluating different types of computational tools requires simulating different types of experiments and extracting different layers of information from the simulation.
    }
    \label{fig:showcase}
\end{figure}


# Results {#sec:dyngen-results}

A cell consists of a set of molecules, the abundance of which is affected by a set of reactions: transcription, splicing, translation, and degradation (Figure\ \ref{fig:simplecyclic}A). A gene regulatory network (GRN) defines the reactions that are allowed to occur (Figure\ \ref{fig:simplecyclic}B), which is constructed in such a way that cells slowly develop over time (Figure\ \ref{fig:simplecyclic}C,D). With every time step $\text{d}t$ in the simulation, the probability of a reaction occurring is computed (not shown). From the probabilities are sampled which reactions occur during this time step $\text{d}t$ (Figure\ \ref{fig:simplecyclic}E). 

\begin{figure}[htb!]
    \centering
    \includegraphics[width=\linewidth]{result_files/fig2_showcase_data/overview.pdf}
    \caption{
        \textbf{dyngen models reactions at a single-molecule level and keeps track of multiple levels of information throughout a simulation.} 
        \textbf{A:} Changes in abundance levels are driven strictly by gene regulatory reactions.
        \textbf{B:} The input GRN is defined such that it models a dynamic process of interest.
        \textbf{C:} The reactions define how abundance levels of molecules change at any particular time point.
        \textbf{D:} Firing many reactions can significantly alter the cellular state over time.
        \textbf{E:} dyngen keeps track of the reactions that were fired during small intervals of time.
        \textbf{F:} Similarly, dyngen can also keep track of the regulatory activity of every interaction.
    }
    \label{fig:simplecyclic}
\end{figure}


dyngen returns many modalities throughout the whole simulation: molecular abundance, number of reaction firings, reaction likelihoods, and regulation activations (Figure\ \ref{fig:simplecyclic}C--F). These modalities can serve both as input data and ground truth for benchmarking many types of computational approaches. For example, a network inference method could use mRNA abundance and regulation activities as inputs and its output could be benchmarked against the gold standard GRN.

Depending on how the GRN is designed, different cellular developmental processes can be simulated.
dyngen includes generators of GRNs which result in many different developmental topologies (Figure\ \ref{fig:example_runs}), including branching, converging, cyclic and even disconnected. Custom-defined GRNs offer more fine-grained control over the simulation.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth]{result_files/fig3_showcase_backbones/overview_2.pdf}
    \caption{
        \textbf{Multiple executions of dyngen with different predefined backbones.} From each simulation of about 200 genes, 1000 cells were sampled.
        \textbf{A:}~Linear. \textbf{B:}~Bifurcating. \textbf{C:}~Converging.
        \textbf{D:}~Cyclic. \textbf{E:}~Bifurcating loop. \textbf{F:}~Bifurcating converging.
        \textbf{G:}~Consecutive branching. \textbf{H:}~Binary tree. \textbf{I:}~Disconnected.
    }
    \label{fig:example_runs}
\end{figure}


Together, these qualities allow it to be applicable in benchmarking a broad range of use-cases. In practice, dyngen has already successfully been used to evaluate trajectory inference [@saelens_comparisonsinglecelltrajectory_2019], trajectory-based differential expression [@vandenberge_trajectorybaseddifferentialexpression_2019], and network inference [@pratapa_benchmarkingalgorithmsgene_2019] methods.
To demonstrate this point even further, we apply dyngen on several promising novel computational approaches for which quantitative assessment of the performance was until now lacking.



## RNA velocity

In eukaryotes, a gene is first transcribed to a pre-mRNA and subsequently spliced into mature mRNA. Because reads coming from both unspliced and spliced transcripts are observed in expression data, the relative ratio between the two can tell us something about which genes are increasing, decreasing or remaining the same [@zeisel_coupledpremrnamrna_2011;@lamanno_rnavelocitysingle_2018]. To determine this, some parameters have to be estimated to determine which fraction of unspliced and spliced mRNAs correspond to an increase or decrease. The estimation of these parameters makes some assumptions and can be handled in different ways in the two main algorithms that are now available for RNA velocity estimation: velocyto [@lamanno_rnavelocitysingle_2018] and scvelo [@bergen_generalizingrnavelocity_2019]. It can be difficult to obtain ground truth data to benchmark these algorithms, given that it would require continuous data of transcriptional dynamics in individual cells. On the other hand, the ground truth velocity is rapidly extracted from the dyngen model, by looking at whether each transcript is currently increasing or decreasing in expression.

We tested scvelo and velocyto on 8 datasets containing linear, bifurcating, disconnected and cyclic trajectories, and varied the main parameter settings in which they estimate the velocity. We found that the original velocyto implementation, which assumes that the velocity remains constant in some cells, performed the best across all datasets. The dynamical estimation of velocyto, as implemented in scvelo, performed the worst of all parameter settings. This was mainly due to scvelo overestimating the dynamics of a gene, especially towards upregulation, while velocyto correctly estimated not only when a gene changes, but also when it remained in a steady state.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{result_files/usecase_rna_velocity/usecase.pdf}
    \caption{
    \textbf{dyngen allows benchmarking of RNA velocity methods.} 
    \textbf{A:} An example bifurcating cycle dataset, with as illustration the expression and ground truth velocity of a gene D1\_TF1 that goes up and down in one branch of the trajectory. 
\textbf{B:} The RNA velocity estimates of gene D1\_TF1 by the different methods.
\textbf{C:} The velocity stream plots produced from the predictions of each method, as generated by scvelo.
\textbf{D:} TODO: discuss new benchmark results
    }
    \label{fig:velocity}
\end{figure}




## Cell-specific network inference

Cell-specific network inference (CSNI) methods\footnote{Different terms are commonly used when dealing with data from a particular source. For example, single-cell NI when applied to single-cell transcriptomics data; sample-specific NI when applied to bulk transcriptomics; patient-derived NI when applied to bulk profiles of patients. A more generalised variant of CSNI is casewise NI, which does not specify the type of data which is being analysed.} predict not only which transcription factors regulate which target genes (Figure\ \ref{fig:scgrn}A, top left), but also how active each interaction is in every case (Figure\ \ref{fig:scgrn}A).


While a few pioneering CSNI approaches have already been developed [@aibar_scenicsinglecellregulatory_2017; @kuijjer_estimatingsamplespecificregulatory_2019; @liu_personalizedcharacterizationdiseases_2016], a quantitative assessment of the performance is until now lacking. This is not surprising, as neither real nor in silico datasets of cell-specific or even cell-type-specific interactions exists that are large enough so that it can be used as a ground-truth for evaluating CSNI methods. Extracting the ground-truth dynamic network in dyngen is straightforward though, given that we can calculate how target gene expression would change without the regulator being present.

We used this ground-truth to compare the performance of three CSNI methods (Figure\ \ref{fig:scgrn}B). We calculated the AUROC and AUPR score -- which are common metrics for NI benchmarking -- for each cell individually. Computing the mean AUROC and AUPR per dataset showed that pySCENIC significantly outperforms LIONESS and SSN.



\begin{figure}[htb!]
    \centering
    \includegraphics[width=.8\linewidth]{result_files/usecase_network_inference/cni.pdf}
    \caption{
    \textbf{dyngen allows benchmarking Cell-specific Network Inference (CSNI) methods.} 
    \textbf{A:} A cell is simulated using the global gene regulatory network (GRN, top left). However, at any particular state in the simulation, only a fraction of the gene regulatory interactions are active.
    \textbf{B:} CSNI methods were executed to predict the regulatory interactions that are active in each cell specifically. Using the ground-truth cell-specific GRN, the performance of each method was quantified on 14 dyngen datasets. 
    }
    \label{fig:scgrn}
\end{figure}





## Trajectory alignment

Trajectory alignment allows studying the differences between the same trajectories from different samples, as shown in Figure \ref{fig:traj_align} A. For example, the cell developmental process of a patient could be compared to that of a healthy control to detect the transcriptomic differences of a particular lineage. 

Dynamic Time Warping (DTW) [@giorgino_computingvisualizingdynamic_2009] is most commonly used to align linear trajectories. DTW is a technique originating in the field of speech recognition and aligns temporal sequences by creating a warping path between the sequences that indicate which sequence must be dilated or contracted to best match the other one. DTW can also be used in combination with smoothed pseudo-cells [@alpert_alignmentsinglecelltrajectories_2018]. 

Trajectory alignment, using DTW, has been used to compare gene expression kinetics resulting from different biological processes [@cacchiarelli_aligningsinglecelldevelopmental_2018], to compare human, chimpanzee and macaque neuronal development [@kanton_organoidsinglecellgenomic_2019], to find differences in gene regulation in the presence of certain growth factors [@mcfaline-figueroa_pooledsinglecellgenetic_2019], and to compare human and mouse embryogenesis [@alpert_alignmentsinglecelltrajectories_2018].

The pseudotime values produced by dyngen are comparable across experiments, which allows us to evaluate the accuracy of an alignment technique. We use DTW, but process the trajectories in 3 different ways: we either used the original cells, we used pseudocells with a smoothed gene expression, or we used every tenth cell in the trajectory. An example of the different results obtained is shown in \ref{fig:traj_align} B, C and D. We can see that the smoothed way of processing recovers the signal in the data best, it finds a diagonal warping path, which indicates that the two trajectories develop in a similar fashion.
We test this on 10 pairs of two datasets, where an increasing amount of noise was added to the count matrix. As shown in Figure \ref{fig:traj_align} E, the smoothed pseudocells perform best.





\begin{figure}[htb!]
    \centering
    \includegraphics[width=.8\linewidth]{result_files/usecase_trajectory_alignment/usecase.pdf}
    \caption{
    \textbf{dyngen allows benchmarking of trajectory alignment methods.} 
 \textbf{A}: Example of a trajectory alignment process. The pseudotimes of individual inferred trajectories can be aligned to indicate differences between the trajectories. 
  \textbf{B, C, D}: Shows the accumulated distance matrices obtained after using DTW on two trajectories where noise (noise level of 0.4) was added to the count matrix. In B the complete count matrices were used to perform the alignment. In C, each 10th cell was used to perform the alignment. In D, smoothed pseudocells were used.
  \textbf{E:} Shows the influence of added noise to the different processing methods. We can see that smoothing performs best in noisy circumstances.
    }
    \label{fig:traj_align}
\end{figure}


# Discussion {#sec:dyngen-discussion}
As is, dyngen's single-cell simulations can be used to evaluate common single-cell omics computational methods such as clustering, batch correction, trajectory inference, and network inference.
However, the combined effect of these advantages results in a framework that is flexible enough to adapt to a broad range of applications. This may include methods that integrate clustering, network inference, and trajectory inference. In this respect, dyngen may promote the development of new tools in the single-cell field similarly as other simulators have done in the past [@schaffter_genenetweaversilicobenchmark_2011; @ewing_combiningtumorgenome_2015].

dyngen ultimately allows anticipating technological developments in single-cell multi-omics. In this way, it is possible to design and evaluate the performance and robustness of new types of computational analyses before experimental data becomes available.
In addition, it could also be used to compare which experimental protocol is the most cost-effective in producing qualitative and robust results in downstream analysis.

Currently, dyngen focuses on simulating cells as standalone entities that are well mixed.
Splitting up the simulation space into separate subvolumes could pave the way to better study key cellular processes such as cell division, intercellular communication, and migration [@smith_spatialstochasticintracellular_2019].


# Methods {#sec:dyngen-methods}
The workflow to generate _in silico_ single-cell data consists of six main steps (Figure\ \ref{fig:explain_methods}).

\begin{figure}[htb!]
    \centering
    \includegraphics[width=\textwidth]{result_files/explain_methods}
    \caption{\textbf{The workflow of dyngen consists of six main steps.} 
    \textbf{A:} The user needs to specify the desired module network or use a predefined module network. The module network is what determines the dynamic behaviour of simulated cells.
    \textbf{B:} The number of desired transcription factors (which drive the desired dynamic process) are amongst the given modules and adds regulatory interactions according to the module network. Additional target genes (which do not influence the dynamic process) are added by sampling interactions from GRN interaction databases.
    \textbf{C:} Each gene regulatory interaction in the GRN is converted to a set of biochemical reactions. 
    \textbf{D:} Along with the module network, the user also needs to specify the backbone structure of expected cell states. The average expression of each edge in the backbone is simulated by activating a restricted set of genes for each edge. 
    \textbf{E:} Multiple Gillespie SSA simulations are run using the reactions defined in step C.  The counts of each of the molecules at each time step are extracted. Each time step is mapped to a point in the backbone. 
    \textbf{F:} The molecule levels of multiple simulations are shown over time (left). From each simulation, multiple cells are sampled (from left to middle). Technical noise from profiling is simulated by sampling molecules from the set of molecules inside each cell (from middle to right).
    }
    \label{fig:explain_methods}
\end{figure}



## Defining the module network {#sec:dyngen-modules}

One of the main processes involved in cellular dynamic processes is gene regulation, where regulatory cascades and feedback loops lead to progressive changes in expression and decision making. The exact way a cell chooses a certain path during its differentiation is still an active research field, although certain models have already emerged and been tested _in vivo_. One driver of bifurcation is mutual antagonism, where two genes strongly repress each other [@rekhtman_directinteractionhematopoietic_1999; @xu_regulationbifurcatingcell_2015], forcing one of the two to become inactive [@graf_forcingcellschange_2009]. Such mutual antagonism can be modelled and simulated [@wang_quantifyingwaddingtonlandscape_2011; @ferrell_bistabilitybifurcationswaddington_2012]. Although the two-gene model is simple and elegant, the reality is frequently more complex, with multiple genes (grouped into modules) repressing each other [@yosef_dynamicregulatorynetwork_2013].

To start a dyngen simulation, the user needs to define a module network. The module network describes how sets of genes regulate each other and is what mainly determines which dynamic processes occur within the simulated cells. 

A module network consists of modules connected together by regulatory interactions, which can be either up- or down-regulating. A module may have basal expression, which means genes in this module will be transcribed without the presence of transcription factor molecules. A module marked as "active during the burn phase" means that this module will be allowed to generate expression of its genes during an initial warm-up phase (See section \ref{sec:dyngen-simcell}). At the end of the dyngen process, cells will not be sampled from the burn phase simulations. Interactions between modules have a strength (which is a positive integer) and an effect (+1 for upregulating, -1 for downregulating).

Several examples of module networks are given (Figure\ \ref{fig:example_backbones_onlymodules}).
A simple chain of modules (where one module upregulates the next) results in a _linear_ process. By having the last module repress the first module, the process becomes _cyclic_. Two modules repressing each other is the basis of a _bifurcating_ process, though several chains of modules have to be attached in order to achieve progression before and after the bifurcation process. Finally, a _converging_ process has a bifurcation occurring during the burn phase, after which any differences in module regulation is removed.

Note that these examples represent the bare minimum in terms of the number of modules used. Using longer chains of modules is typically desired. In addition, the fate decisions made in this example of a bifurcation is reversible, meaning cells can be reprogrammed to go down a different differentiation path. If this effect is undesirable, more safeguards need to be put in place to prevent reprogramming from occurring (Section \ref{sec:dyngen-bbl}).

\begin{figure}[htb!]
    \centering
    \includegraphics[width=0.8\textwidth]{result_files/example_backbones_onlymodules}
    \caption{
      \textbf{The module network determines the type of dynamic process which simulated cells will undergo.} A module network describes the regulatory interactions between sets of transcription factors which drive the desired dynamic process.
    }
    \label{fig:example_backbones_onlymodules}
\end{figure}






## Generating the gene regulatory network {#sec:dyngen-grn}
The GRN is generated based on the given module network in four main steps (Figure\ \ref{fig:gen_feature_network}).

\begin{figure}[htb!]
    \centering
    \includegraphics[width=\linewidth]{result_files/gen_feature_network}
    \caption{
        \textbf{Generating the feature network from a backbone consists of four main steps.}
    }
    \label{fig:gen_feature_network}
\end{figure}


**Step 1, sampling the transcription factors (TF).** The TFs are the main drivers of the molecular changes in the simulation. The user provides a backbone and the number of TFs to generate. Each TF is assigned to a module such that each module has at least $x$ parameters (default $x=1$). A TF inherits the 'burn' and 'basal expression' from the module it belongs to.

**Step 2, generating the TF interactions.** Let each TF be regulated according to the interactions in the backbone. These interactions inherit the effect, strength, and independence parameters from the interactions in the backbone. A TF can only be regulated by other TFs or itself.

**Step 3, sampling the target subnetwork.**
A user-defined number of target genes are added to the GRN. Target genes are regulated by a TF or another target gene, but are always downstream of at least one TF. To sample the interactions between target genes, one of the many FANTOM5 \cite{lizio_gatewaysfantom5promoter_2015} GRNs is sampled. The currently existing TFs are mapped to regulators in the FANTOM5 GRN. The targets are drawn from the FANTOM5 GRN, weighted by their page rank value. For each target, at most $x$ regulators are sampled from the induced FANTOM5 GRN (default $x=5$). The interactions connecting a target gene and its regulators are added to the GRN.

**Step 4, sampling the housekeeping subnetwork.**
Housekeeping genes are completely separate from any TFs or target genes. A user-defined set of housekeeping genes are also sampled from the FANTOM5 GRN. The interactions of the FANTOM5 GRN are first subsampled such that the maximum in-degree of each gene is $x$ (default $x=5$). A random gene is sampled and a breadth-first-search is performed to sample the desired number of housekeeping genes.


## Convert gene regulatory network to a set of reactions {#sec:dyngen-reactions}

\newcommand{\x}[1]{\text{x}_{#1}}
\newcommand{\y}[1]{\text{y}_{#1}}
\newcommand{\z}[1]{\text{z}_{#1}}


\newcommand{\rs}[1]{\text{R}_{#1}}
\newcommand{\rp}[1]{\text{R}^+_{#1}}
\newcommand{\rn}[1]{\text{R}^-_{#1}}

\newcommand{\xpr}[1]{\text{xpr}_{#1}}
\newcommand{\xhl}[1]{\text{xhl}_{#1}}
\newcommand{\ysr}[1]{\text{ysr}_{#1}}
\newcommand{\yhl}[1]{\text{yhl}_{#1}}
\newcommand{\ydr}[1]{\text{ydr}_{#1}}
\newcommand{\zpr}[1]{\text{zpr}_{#1}}
\newcommand{\zhl}[1]{\text{zhl}_{#1}}
\newcommand{\zdr}[1]{\text{zdr}_{#1}}

\newcommand{\str}[1]{\text{str}_{#1}}
\newcommand{\hill}[1]{\text{hill}_{#1}}
\newcommand{\ind}[1]{\text{ind}_{#1}}
\newcommand{\dis}[1]{\text{dis}_{#1}}
\newcommand{\buf}[1]{\text{bind}_{#1}}
\newcommand{\ba}[1]{\text{bas}_{#1}}

Simulating a cell's GRN makes use of a stochastic framework which tracks the abundance levels of molecules over time in a discrete quantity. For every gene $G$, the abundance levels of three molecules are tracked, namely of corresponding pre-mRNAs, mature mRNAs and proteins, which are represented by the terms $\x G$, $\y G$ and $\z G$ respectively. The GRN defines how a reaction affects the abundance levels of molecules and how likely it will occur. Gibson and Bruck [@gibson_probabilisticmodelprokaryotic_2000] provide a good introduction to modelling gene regulation with stochastic frameworks, on which many of the concepts below are based.

For every gene in the GRN a set of reactions are defined, namely transcription, splicing, translation, and degradation. Each reaction consists of a propensity function -- a formula $f(.)$ to calculate the probability $f(.) \times \text{d}t$ of it occurring during a time interval $\text{d}t$ -- and the effect -- how it will affect the current state if triggered. 

The effects of each reaction mimic the respective biological processes (Table\ \ref{tab:reaction_def}, middle). Transcription of gene $G$ results in the creation of a single pre-mRNA molecule $\x G$. Splicing turns one pre-mRNA $\x G$ into a mature mRNA $\x G$. Translation uses a mature mRNA $\y G$ to produce a protein $\z G$. Pre-mRNA, mRNA and protein degradation results in the removal of a $\x G$, $\y G$, and $\z G$ molecule, respectively.

The propensity of all reactions except transcription are all linear functions (Table\ \ref{tab:reaction_def}, right) of the abundance level of some molecule multiplied by a per-gene constant (Table\ \ref{tab:reaction_params}). The propensity of transcription of a gene $G$ depends on the abundance levels of its TFs. The per-gene and per-interaction constants are based on the median reported production-rates and half-lives of molecules measured of 5000 mammalian genes [@schwanhausser_globalquantificationmammalian_2011], except that the transcription rate has been amplified by a factor of 10.



\begin{table}[ht]
    \caption{
      \textbf{Reactions affecting the abundance levels of pre-mRNA $\x G$, mature mRNA $\y G$ and proteins $\z G$ of gene $G$.} Define the set of regulators of $G$ as $\rs{G}$, the set of upregulating regulators of $G$ as $\rp G$, and the set of downregulating regulators of $G$ as $\rn G$. Parameters used in the propensity formulae are defined in Table \ref{tab:reaction_params}.
    } \label{tab:reaction_def}
    \centering
    \begin{tabular}{|lcc|}
        \hline
        Reaction & Effect & Propensity \\ \hline \hline
        Transcription & $\emptyset \rightarrow \x G$ & $\xpr G \times \frac{\ba G - \ind{G}^{|\rp{G}|} + \prod\limits_{H \in \rp{G}}(\ind G + \buf{G,H})}{\prod\limits_{H \in \rs{G}}(1 + \buf{G,H})}$ \\
        Splicing & $\x G \rightarrow \y G$ & $\ysr G \times \x G$ \\
        Translation & $\y G \rightarrow \y G + \z G$ & $\zpr G \times \y G$ \\ \hline\hline
        Pre-mRNA degradation & $\x G \rightarrow \emptyset$ & $\ydr G \times \x G$ \\
        Mature mRNA degradation & $\y G \rightarrow \emptyset$ & $\ydr G \times \y G$ \\
        Protein degradation & $\z G \rightarrow \emptyset$ & $\zdr G \times \z G$ \\ \hline
    \end{tabular}
\end{table}


\begin{table}[ht]
    \caption{
      \textbf{Default parameters defined for the calculation of reaction propensity functions.}
    } \label{tab:reaction_params}
    \centering
    \begin{tabular}{|lrl|}
        \hline
        Parameter & Symbol & Definition \\ \hline \hline
        Transcription rate & $\xpr{G}$ & $\in U(10, 20)$ \\
        Splicing rate & $\ysr G$ & $= \ln(2)\ /\ 2$ \\
        Translation rate & $\zpr{G}$ & $\in U(100, 150)$ \\
        (Pre-)mRNA half-life & $\yhl{G}$ & $\in U(2.5, 5)$ \\
        Protein half-life & $\zhl G$ & $\in U(5, 10)$ \\
        Interaction strength & $\str{G,H}$ & $\in 10^{U(0, 2)}$ * \\
        Hill coefficient & $\hill{G,H}$ & $\in U(0.5, 2)$ * \\
        Independence factor & $\ind G$ & $\in U(0, 1)$ * \\ \hline\hline
        (Pre-)mRNA degradation rate & $\ydr G$ & $= \ln(2)\ /\ \yhl G$ \\
        Protein degradation rate & $\zdr G$ & $= \ln(2)\ /\ \zhl G$ \\
        Dissociation constant & $\dis H$ & $= 0.5 \times \frac{\xpr H \times \ysr H \times \zpr H}{(\ydr H + \ysr H) \times \ydr H \times \zdr H}$ \\
        Binding strength & $\buf{G,H}$ & $= \str{G,H} \times \left(\z H\ /\ \dis H\right) ^ {\hill{G,H}}$ \\
        Basal expression & $\ba G$ & $= \begin{cases} 1 & \mbox{if } \rp{G} = \emptyset \\ 0.0001 & \mbox{if } \rn{G} = \emptyset \mbox{ and } \rp{G} \neq \emptyset \\ 0.5 & \mbox{otherwise} \end{cases}$ * \\ \hline
        \multicolumn{3}{l}{*: unless $G$ is a TF, then the value is determined by the backbone.}
    \end{tabular}
\end{table}




\newcommand{\proptran}{f}
\newcommand{\ai}[2]{$S_{#1} = S_{#2b}$}
\newcommand{\zk}[1]{\frac{y_#1}{k_#1}^{c_#1}}
\newcommand{\wi}[1]{\nu_#1}

The propensity of the transcription of a gene $G$ is inspired by thermodynamic models of gene regulation [@schilstra_biologicgeneexpression_2008], in which the promoter of $G$ can be bound or unbound by a set of $N$ transcription factors $H_i$. Let $\proptran(\z 1, \z 2, \ldots, \z N)$ denote the propensity function of $G$, in function of the abundance levels of the transcription factors. The following subsections explain and define the propensity function when $N=1$, $N=2$, and finally for an arbitrary $N$.


### Propensity of transcription when $N=1$
In the simplest case when $N=1$, the promoter can be in one of two states. In state $S_0$, the promoter is not bound by any transcription factors, and in state $S_1$ the promoter is bound by $H_1$. Each state $S_j$ is linked with a relative activation $\alpha_j$, a number between 0 and 1 representing the activity of the promoter at this particular state. The propensity function is thus equal to the expected value of the activity of the promoter multiplied by the pre-mRNA production rate of $G$.

\begin{align}
  f(y_1, y_2, \ldots, y_N) & = \text{xpr} \cdot \sum_{j = 0}^{2^N - 1} \alpha_j \cdot P(S_j) \label{eqn:activ0} \\
\end{align}

For $N=1$, $P(S_1)$ is equal to the Hill equation, where $k_i$ represents the concentration of $H_i$ at half-occupation and $n_i$ represents the Hill coefficient. Typically, $n_i$ is between [1,10]

\begin{align}
  P(S_1) & = \frac{y_1^{n_1}}{k_1^{n_1} + y_1^{n_1}} \\
     & = \frac{(y_1/k_1)^{n_1}}{1 + (y_1/k_1)^{n_1}}
\end{align}

The Hill equation can be simplified by letting $\nu_i = \left(\frac{y_i}{k_i}\right)^{n_i}$.


\begin{align}
P(S_1) & = \frac{\nu_1}{1 + \nu_1} \label{eqn:hillsimp}
\end{align}

Since $P(S_0) = 1 - P(S_1)$, the activation function is formulated and simplified as follows.


\begin{align}
f(y_1) & = \text{xpr} \cdot \left(\alpha_0 \cdot P(S_0) + \alpha_1 \cdot P(S_1)\right) \\
   & = \text{xpr} \cdot \left(\alpha_0 \cdot \frac{1}{1 + \nu_1} + \alpha_1 \cdot \frac{\nu_1}{1 + \nu_1}\right) \\
   & = \text{xpr} \cdot \frac{\alpha_0 + \alpha_1 \cdot \nu_1}{1 + \nu_1} \\
\end{align}



### Propensity of transcription when $N=2$

When $N=2$, there are four states $S_j$. The relative activations $\alpha_j$ can be defined such that $H_1$ and $H_2$ are independent (additive) or synergistic (multiplicative). In order to define the propensity of transcription $f(.)$, the Hill equation $P(S_j)$ is extended for two transcription factors.

Let $w_j$ be the numerator of $P(S_j)$, defined as the product of all transcription factors bound in that state:

\begin{align}
w_0 & = 1 \\
w_1 & = \nu_1 \\
w_2 & = \nu_2 \\
w_3 & = \nu_1 \cdot \nu_2
\end{align}

The denominator of $P(S_j)$ is then equal to the sum of all $w_j$. The probability of state $S_j$ is thus defined as:

\begin{align}
    P(S_j) & = \frac{w_j}{\sum_{j=0}^{j < 2^N} w_j} \\
       & = \frac{w_j}{1 + \nu_1 + \nu_2 + \nu_1 \cdot \nu_2} \\
       & = \frac{w_j}{\prod_{i=1}^{i \leq N} (\nu_i + 1)}
\end{align}

Substituting $P(S_j)$ and $w_j$ into $f(.)$ results in the following equation:

\begin{align}
f(y_1, y_2) & = \text{xpr} \cdot \sum_{j = 0}^{2^N - 1} \alpha_j \cdot P(S_j) \\
 & = \text{xpr} \cdot \frac{\sum_{j = 0}^{2^N - 1} \alpha_j \cdot w_j}{\prod_{i=1}^{i \leq N} (\nu_i + 1)} \\
 & = \text{xpr} \cdot \frac{\alpha_0 + \alpha_1 \cdot \nu_1 + \alpha_2 \cdot \nu_2 + \alpha_3 \cdot \nu_1 \cdot \nu_2}{(\nu_1 + 1) \cdot (\nu_2 + 1)} \\
\end{align}



### Propensity of transcription for an arbitrary $N$
For an arbitrary $N$, there are $2^N$ states $S_j$. The relative activations $\alpha_j$ can be defined such that $H_1$ and $H_2$ are independent (additive) or synergistic (multiplicative). In order to define the propensity of transcription $f(.)$, the Hill equation $P(S_j)$ is extended for $N$ transcription factors.

Let $w_j$ be the numerator of $P(S_j)$, defined as the product of all transcription factors bound in that state:

\begin{align}
  w_j & = \prod_{i=1}^{i \leq N} (j \text{ mod } i) = 1 \text{ ? } \nu_i \text{ : } 1
\end{align}

The denominator of $P(S_j)$ is then equal to the sum of all $w_j$. The probability of state $S_j$ is thus defined as:

\begin{align}
P(S_j) & = \frac{w_j}{\sum_{j=0}^{j < 2^N} w_j} \\
& = \frac{w_j}{\prod_{i=1}^{i \leq N} (\nu_i + 1)}
\end{align}

Substituting $P(S_j)$ into $f(.)$ yields:

\begin{align}
f(y_1, y_2, \ldots, y_N) & = \text{xpr} \cdot \sum_{j = 0}^{2^N - 1} \alpha_j \cdot P(S_j) \\
& = \text{xpr} \cdot \frac{\sum_{j = 0}^{2^N - 1} \alpha_j \cdot w_j}{\prod_{i=1}^{i \leq N} (\nu_i + 1)} \label{eqn:prop2n}
\end{align}


### Propensity of transcription for a large $N$
For large values of $N$, computing $f(.)$ is practically infeasible as it requires performing $2^N$ summations. In order to greatly simplify $f(.)$, $\alpha_j$ could be defined as 0 when one of the regulators inhibits transcription and 1 otherwise.

\begin{equation}
\alpha_j = \begin{cases}
 0 & \text{ if } \exists i : j \text{ mod } i = 1 \text{ and } H_i \text{ represses } G \\
 1 & \text{otherwise}
\end{cases} \label{eqn:assalpha}
\end{equation}

Substituting equation \ref{eqn:assalpha} into equation \ref{eqn:prop2n} and defining $R = \{1, 2, \ldots, N\}$ and $R^+ = \{i | H_i \text{ activates } G\}$ yields the simplified propensity function:

\begin{align}
f(y_1, y_2, \ldots, y_N) & = \text{xpr} \cdot \frac{\prod_{i \in R^+} (\nu_i + 1)}{\prod_{i \in R} (\nu_i + 1)}
\end{align}


### Independence, synergism and basal expression
The definition of $\alpha_j$ as in equation \ref{eqn:assalpha} presents two main limitations. Firstly, since $\alpha_0 = 1$, it is impossible to tweak the propensity of transcription when no transcription factors are bound. Secondly, it is not possible to tweak the independence and synergism of multiple regulators.

Let $\text{ba} \in [0,1]$ denote the basal expression strength $G$ (i.e. how much will $G$ be expressed when no transcription factors are bound), and $\text{sy} \in [0,1]$ denote the synergism of regulators $H_i$ of $G$, the transcription propensity becomes:

\begin{align}
f(y_1, y_2, \ldots, y_N) & = \text{xpr} \cdot \frac{\text{ba} - \text{sy}^{|R^+|} + \prod_{i \in R^+} (\nu_i + \text{sy})}{\prod_{i \in R} (\nu_i + 1)}
\end{align}

## Simulate single cells {#sec:dyngen-simcell}
dyngen uses Gillespie's stochastic simulation algorithm (SSA) [@gillespie_exactstochasticsimulation_1977] to simulate dynamic processes. An SSA simulation is an iterative process where at each iteration one reaction is triggered.

Each reaction consists of its propensity -- a formula to calculate the probability of the reaction occurring during an infinitesimal time interval -- and the effect -- how it will affect the current state if triggered. Each time a reaction is triggered, the simulation time is incremented by $\tau = \frac{1}{\sum_j prop_j} \ln\left(\frac{1}{r}\right)$, with $r \in U(0, 1)$ and $prop_j$ the propensity value of the $j$th reaction for the current state of the simulation.

GillespieSSA2 is an optimised library for performing SSA simulations. The propensity functions are compiled to C++ and SSA approximations can be used which allow triggering many reactions simultaneously at each iteration. The framework also allows storing the abundance levels of molecules only after a specific interval has passed since the previous census. By setting the census interval to 0, the whole simulation's trajectory is retained but many of these time points will contain very similar information. In addition to the abundance levels, also the propensity values and the number of firings of each of the reactions at each of the time steps can be retained, as well as specific sub-calculations of the propensity values, such as the regulator activity level $reg_{G,H}$.


## Simulate experiment {#sec:dyngen-experiment}
From the SSA simulation we obtain the abundance levels of all the molecules at every state. We need to replicate technical effects introduced by experimental protocols in order to obtain data that is similar to real data. For this, the cells are sampled from the simulations and molecules are sampled for each of the cells. Real datasets are used in order to achieve similar data characteristics.


### Sample cells
In this step, $N$ cells are sampled the simulations. Two approaches are implemented: sampling from an unsynchronised population of single cells (snapshot) or sampling at multiple time points in a synchronised population (time series).

**Snapshot** The backbone consists of several states linked together by transition edges with length $L_i$, to which the different states in the different simulations have been mapped (Figure\ \ref{fig:sample_cells}A). From each transition, $N_i = N / \frac{L_i}{\sum L_i}$ cells are sampled uniformly, rounded such that $\sum N_i = N$.

**Time series** Assuming that the final time of the simulations is $T$, the interval $[0, T]$ is divided into $k$ equal intervals of width $w$ separated by $k-1$ gaps of width $g$. $N_i = N / k$ cells are sampled uniformly from each interval (Figure\ \ref{fig:sample_cells}B), rounded such that $\sum N_i = N$. By default, $k = 8$ and $g = 0.75$. For usual dyngen simulations, $10 \leq T \leq 20$. For larger values of $T$, $k$ and $g$ should be increased accordingly.

\begin{figure}[htb!]
    \centering
    \includegraphics[width=.6\linewidth]{result_files/sample_cells.pdf}
    \caption{
        \textbf{Two approaches can be used to sample cells from simulations: snapshot and time-series.}
    }
    \label{fig:sample_cells}
\end{figure}



### Sample molecules
Molecules are sampled from the simulation to replicate how molecules are experimentally sampled. A real dataset is downloaded from a repository of single-cell RNA-seq datasets [@cannoodt_singlecellomicsdatasets_2018]. For each _in silico_ cell $i$, draw its library size $ls_i$ from the distribution of transcript counts per cell in the real dataset. The capture rate $cr_j$ of each _in silico_ molecule type $j$ is drawn from $N(1, 0.05)$. Finally, for each cell $i$, draw $ls_i$ molecules from the multinomial distribution with probabilities $cr_j \times ab_{i,j}$ with $ab_{i,j}$ the molecule abundance level of molecule $j$ in cell $i$.


## Determining the ground-truth trajectory {#sec:dyngen-groundtruth}
To determine the state of a cell at any point in the simulation, we simulate the expression of the ground-truth trajectory. Subsequently, map the expression of the cell to the closest resembling state in the ground-truth trajectory by finding the point in the ground-truth trajectory with the highest Pearson correlation value w.r.t. the expression values. 

To simulate the expression of the ground-truth expression, we iterate over the edges in the backbone state network starting from the root state. We assume the root state has no modules active and has no expression of any molecules. To transition to a next state, we activate or deactivate certain gene modules as defined by the backbone (Section\ \ref{sec:dyngen-modules}) and perform a noiseless ODE simulation. For each time interval $t=0.01$ along the trajectory, the expression values are retained.


## Constructing backbones {#sec:dyngen-backbone}

\begin{figure}[htb!]
    \centering
    \includegraphics[width=0.8\textwidth]{result_files/example_backbones}
    \caption{
      TODO
    }
    \label{fig:example_backbones}
\end{figure}

### Backbone lego {#sec:dyngen-bbl}
The backbone can make use of one or more "backbone lego" (BBL) pieces (Figure\ \ref{fig:backbone_lego}). A BBL consists of one or more modules which regulate each other such that the output modules present a specific behaviour, depending on the input module (Figure\ \ref{fig:backbone_lego}A). Parameters allow determining the number of modules involved in the process and the number of outputs. Multiple BBLs can be chained together in order to intuitively create module networks and corresponding state networks (Figure\ \ref{fig:backbone_lego}B). Note that not all dynamic processes can be represented by a combination of BBLs, but they can serve as common building blocks to aid the construction of the backbone.

\begin{figure}[htb!]
    \centering
    \includegraphics[width=0.8\textwidth]{result_files/backbone_lego}
    \caption{
      \textbf{Reusable regulatory building blocks that can be used to construct GRNs that result in dynamic processes following an expected pattern.}
      \textbf{A:} Each building block contains genes which serve as inputs that can be regulated by external transcription factors. The connections inside the building block transform the input signal in a particular way and has one or more output interactions of which the targets are not yet determined.
      \textbf{B:} By connecting multiple building blocks together, a backbone of regulatory modules can be formed.
      \textbf{C:} dyngen offers several variations of linear building blocks which allow for differing regulatory mechanisms.
      \textbf{D:} A branching module will upregulate the expression of just one of the output interactions. Two variations are given of which the simple variant is more prone to reprogramming events in comparison to the robust branching module.
      \textbf{E,F:} These components allow to specify the beginning (no inputs) and end (no outputs) of the backbone.
    }
    \label{fig:backbone_lego}
\end{figure}


When the input node of a **linear BBL** (Figure\ \ref{fig:backbone_lego}C) is upregulated, the module the BBL is connected to will be upregulated. A _simple chain_ is a set of modules where a module upregulates the next. A _chain with double repression_ has an uneven number of modules forming a chain where each module downregulates the next but all modules (except the input) have basal expression. A _grid with double repression_ is similar; except that modules do not have basal expression but instead get upregulated by an upstream module in the chain. Finally, a _flip flop_} consists of a simple chain where first the modules (except the last) are upregulated. Once the second to last module is upregulated, that module upregulates itself and the first module is strongly repressed, causing all other modules to lose expression and finally the last module to be upregulated. The _flip flop_ retains this output state, even when the input changes.

When the input node of a **branching BBL** (Figure\ \ref{fig:backbone_lego}D) is upregulated, a subset of its output modules will eventually be upregulated. A \emph{simple branching} uses reciprocal inhibition to drive the upregulation of one of the output modules. Due to its simplicity, however, multiple output modules might be upregulated simultaneously and over long periods of simulation time it might be possible that the choice of upregulated module changes. A _robust branching_ improves upon the simple branching by preventing upregulation of output modules until an internal branching decision has been made, and by repressing the decision mechanism to avoid other output modules being upregulated other than the one that has been chosen.

A **leaf BBL** (Figure\ \ref{fig:backbone_lego}E) is a linear BBL that has either no inputs or no outputs. A _start_ BBL is a linear BBL where the first module has basal expression, and all modules in this module will be active during the burn-in phase of the simulation. An _end_ BBL is also a linear BBL with its output regulating one final module.

## Determining the cell-specific ground-truth regulatory network {#sec:dyngen-extractgrn}
Calculating the regulatory effect of a regulator $R$ on a target $T$ (Figure\ \ref{fig:explain_methods}F) requires determining the contribution of $R$ in the propensity function of the transcription of $T$ (section\ \ref{sec:dyngen-reactions}) with respect to other regulators. This information is useful, amongst others, for benchmarking cell-specific network inference methods. 

The regulatory effect of $R$ on $T$ at a particular state $S$ is defined as the change in the propensity of transcription when $R$ is set to zero, scaled by the inverse of the pre-mRNA production rate of $T$. More formally:

\begin{eqnarray*}
  \text{regeffect}_G & = \frac{\text{proptrans}_G(S) - \text{proptrans}_G(S[\z T \leftarrow 0])}{\xpr G}
\end{eqnarray*}

Determining the regulatory effect for all interactions and cells in the dataset yields the complete cell-specific ground-truth GRN (Figure\ \ref{fig:cell-specific_grn}). The regulatory effect lie between $[-1, 1]$, where -1 represents complete inhibition of $T$ by $R$, 1 represents maximal activation of $T$ by $R$, and 0 represents inactivity of the regulatory interaction between $R$ and $T$.

\begin{figure}[htb!]
    \centering
    \includegraphics[width=.8\linewidth]{result_files/fig1_showcase_functionality/scgrn.pdf}
    \caption{
        \textbf{The cell-specific regulatory effects of all interactions, computed on cells part of a bifurcation trajectory.} Negative values correspond to inhibitory interactions, positive values to activating interactions, and zero values correspond to inactive interactions. 
    }
    \label{fig:cell-specific_grn}
\end{figure}



## Comparison of cell-specific network inference methods {#sec:dyngen-nicompare}
Several datasets were generated using the different predefined backbones. For every cell in the dataset, the transcriptomics profile and the corresponding cell-specific ground-truth regulatory network was determined (Section\ \ref{sec:dyngen-extractgrn}). 

Several cell-specific NI methods were considered for comparison: SCENIC [@aibar_scenicsinglecellregulatory_2017], LIONESS [@kuijjer_estimatingsamplespecificregulatory_2015; @kuijjer_estimatingsamplespecificregulatory_2019], and SSN [@liu_personalizedcharacterizationdiseases_2016]. 

LIONESS [@kuijjer_estimatingsamplespecificregulatory_2019] runs a NI method multiple times to construct cell-specific GRNs. LIONESS first infers a GRN with all of the samples. A second GRN is inferred with all samples except one particular profile. The cell-specific GRN for that particular profile is defined as the difference between the two GRN matrices. This process is repeated for all profiles, resulting in a cell-specific GRN. By default, LIONESS uses PANDA [@glass_passingmessagesbiological_2013] to infer GRNs, but since dyngen does not produce motif data and motif data is required by PANDA, PANDA is inapplicable in this context. Instead, we used the lionessR [@kuijjer_lionessrsinglesample_2019] implementation of LIONESS, which uses by default the Pearson correlation as a NI method. We marked results from this implementation as "LIONESS + Pearson".

SSN [@liu_personalizedcharacterizationdiseases_2016] follows, in essence, the exact same methodology as LIONESS except that it specifically only uses the Pearson correlation. It is worth noting that the LIONESS preprint was released before the publication of SSN. Since no implementation was provided by the authors, we implemented SSN in R using basic R and tidyverse functions [@wickham_welcometidyverse_2019] and marked results from this implementation as "SSN*".

SCENIC [@aibar_scenicsinglecellregulatory_2017] is a pipeline that consists of four main steps. Step 1: classical network inference is performed with arboreto, which is similar to GENIE3 [@huynh-thu_inferringregulatorynetworks_2010]. Step 2: select the top 10 regulators per target. Interactions are grouped together in 'modules'; each module contains one regulator and all of its targets. Step 3: filter the modules using motif analysis. Step 4: for each cell, determine an activity score of each module using AUCell. As a post-processing of this output, all modules and the corresponding activity scores are combined back into a cell-specific GRN consisting of (cell, regulator, target, score) pairs. For this analysis, the Python implementation of SCENIC was used, namely pySCENIC. Since dyngen does not generate motif data, step 3 in this analysis is skipped.

The AUROC and AUPR metrics are common metrics for evaluating a predicted GRN with a ground-truth GRN. To compare a predicted cell-specific GRN with the ground-truth cell-specific GRN, the top 10'000 interactions per cell were retained. For each cell-specific network, the AUROC and AUPR were calculated.


## Comparison of RNA velocity methods {#sec:dyngen-velcompare}

15 datasets were generated with 5 different backbones: linear, linear simple, bifurcating, cyclic, and disconnected. We extracted a ground truth RNA velocity by subtracting for each mRNA molecule the propensity of its production by the propensity of its degradation. If the expression of an mRNA will increase in the future, this value is positive, while it is negative if it is going to decrease. For each gene, we compared the ground truth velocity with the observed velocity by calculating the Spearman rank correlation.

We compared two RNA velocity methods. The velocyto method [@lamanno_rnavelocitysingle_2018], as implemented in the velocyto.py package, in which we varied the "assumption" parameter between "constant_unspliced" and "constant_velocity". The scvelo method [@bergen_generalizingrnavelocity_2019], as implemented in the python scvelo package [scvelo.de](http://scvelo.de), in which we varied the "mode" parameter between "deterministic", "stochastic" and "dynamical". For both methods, we used the same normalized data as provided by dyngen, with no extra cell or feature filtering. We also matched the parameters between both methods as best as possible, i.e. the k parameter for smoothing was set to 20 for both methods.

To visualize the velocity on an embedding, we used the "velocity_embedding" function, implemented in the scvelo python package.


## Comparison of trajectory alignment with added noise {#sec:dyngen-tacompare}

We generated 10 base datasets that contain a linear trajectory using dyngen. For each dataset, we performed the cell generation and experiment generation twice. This results in 20 datasets, with 10 pairs of similar trajectories.
For each of these pairs of datasets, we generated 10 progressively noisier pairs, in which we added noise to the complete count matrix.
Let $q$ be the 75th quantile of the non-zero values in the count matrix. The noise added to the count matrix is calculated as follows, with $i$ being the noise parameter.
\begin{equation}
 countmatrix + \frac{1}{\sqrt{2\pi}}qie^{\frac{x^2}{2(qi)^2}}  \quad \forall i \in \{0.1, 0.2, ... 1.0\}
\end{equation}

We aligned each of these 150 pairs of trajectories (the first trajectory in the pair with the second trajectory in the pair) in 3 different ways. Either we used the original count matrix, we used 1/10th of the cells (according to the ordering of the trajectory, so the 1st, 10th, 20th, ... cell of the trajectory) or we used the smoothed pseudocells.
The pseudocells are generated at regular points across the pseudotime of the trajectory. The gene expression of each pseudocell is inferred using a Gaussian kernel with a window size of 0.05.

Each of the cells or pseudocells received a pseudotime from dyngen. This time can be compared: cells from the first trajectory in the pair should be aligned closely to cells from the second trajectory with similar pseudotimes. We used the sum of differences between the pseudotimes of the aligned cells to determine the distance between the two trajectories, which should ideally be 0. In order to compare the alignments with 1000 cells per trajectory and the ones with 100 cells per trajectory, we divide the distance of those alignments by 10.

# Availability
dyngen is available as an R package on GitHub [github.com/dynverse/dyngen](https://github.com/dynverse/dyngen). The dyngen codebase is still under development and is thus likely subject to change, including the adding or removing of functionality, renaming functions or parameters, and changing default parameter values. The analyses performed in this manuscript are available on GitHub [github.com/dynverse/dyngen_manuscript](https://github.com/dynverse/dyngen_manuscript). 

# Author contributions

* W.S. and R.C. designed the study.
* R.C., W.S., and L.D. performed the experiments and analysed the data.
* R.C. and W.S. implemented the dyngen software package.
* R.C. and W.S. wrote the original manuscript.
* L.D. wrote the section on trajectory alignment.
* R.C., W.S., L.D., and Y.S. reviewed and edited the manuscript.
* Y.S. supervised the project.



